LINUX HEAP BUFFER OVERFLOW:
create_list /home/code/42/minishell/create_list.c:47


-	Parser:
Reads everything and puts it all into a struct (linked list perhaps).

quotes should work as followed: (used echo for testing)

"welcome to the world"		=	welcome to the world
'welcome to the world'		=	welcome to the world
"welcome to "the" world"	=	welcome to the world
"welcome to 'the' world"	=	welcome to 'the' world
'welcome to "the" world'	=	welcome to "the" world
"welcome to the world's"	=	welcome to the world's
'welcome to the world"s'	=	welcome to the world"s

"welcome to the world"s"	=X	dquote>


history <<<$has |||told us "life is $USER like a'asd' potato" but its all a lie

history
<<
<
has
told
us
"life is like a potato"
but
it's
all
a
lie

"lorenzo" is "a good" coder ==
"lorenzo"
is							
"a good"
coder

w "a" d
0 == w
1 == 32
2 == quote
3 == d
4 == quote
5 == 32
6 == a


-	Executor
Takes the linked list and executes the simpleCommands in the following order:


cat file1.txt | grep "e" | sort -r | head -n 10 > outfile < infile > errfile

cat file1.txt
	grep
		sort
			head > put it in outfile and errfile
				redo all of it but with infile


- Shell Subsystems
env $VAR

-Signals:
	ctrl+c works fine
	ctrl+\ needs to work with a PID because it has to stop childprocess or do nothing, not sure, but currently it does nothing
	ctrl+d segfaults

-kenny tasks
	figure out what olebolcode does
		- if i'm correct, ole uses the path to execute existing commands, but hasnt worked on the built-ins yet.

	get the pid of childprocess to make ctrl+\ function correctly. Currently it does nothing, which could be correct depending on the subjectpage.

	figure out the segfault at ctrl+d. It segfaulted because of strncmp. it doesn't segfault anymore but if ctrl+c and then ctrl+d, it gives an extra \n. No idea why.

	A new error occurred when ctrl+c is done. it shows "aardappelschill>> aardappelschill>> ", twice, which is a problem

error/exit handling:
	- with "echo $?" we can check with what exit() code the program exited.
	- usually when something when well, it exits with a 0. 
	- it might mean we need to use waitpid().